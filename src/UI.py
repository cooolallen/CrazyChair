# ui generated by 
# pyuic5 MainWindow.ui -o ui_MainWindow.py
# pyuic5 RecordData.ui -o ui_RecordData.py

from PyQt5.QtWidgets import QMainWindow, QDialog, QShortcut, QMessageBox

from UIs.ui_MainWindow import Ui_MainWindow
from UIs.ui_RecordData import Ui_DataRecorder
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QPixmap, QKeySequence, QGuiApplication

from ArduinoTest import ArduinoTest
from SVM import Judge
import Constants

import serial
import struct
import datetime
from enum import Enum
from collections import defaultdict
from matplotlib import pyplot as plt
from os.path import join
import os


class Posture(Enum):
	empty = 0
	normal = 1
	normalBack = 2
	lay = 3
	legOnLeft = 4
	legOnRight = 5

	def __str__(self):
		if self.value == 0:
			return 'empty'
		elif self.value == 1:
			return 'normal'
		elif self.value == 2:
			return 'normalBack'
		elif self.value == 3:
			return 'lay'
		elif self.value == 4:
			return 'legOnLeft'
		else:
			return 'legOnRight'
       

class MainWindow(QMainWindow):
	def __init__(self, test=False, port=None, parent=None):
		# UI init
		super(MainWindow, self).__init__(parent)
		self.ui = Ui_MainWindow()
		self.ui.setupUi(self)

		self.voltageTimer = QTimer()
		self.voltageTimer.start(100)		# update every 0.1 second
		self.guiTimer = QTimer()
		self.guiTimer.start(0)
		self.cm = plt.get_cmap('cool')
		self.init = False					# will be removed when hand-shake is added
		self.recorder = None
		self.time = None
		self.measure = None
		self.judge = Judge()
		self.predict = {'predict':1, 'cnt':0, 'curr_predict':None}


		# check it is test mode or not (arduino don't need to connect)
		if test:
			self.arduino = ArduinoTest()
		else:
			self.arduino = serial.Serial(port, 9600, timeout=.1)

		# Connection
		self.voltageTimer.timeout.connect(self.voltageUpdate)
		self.ui.actionRecord_Data.triggered.connect(self.recordData)
		self.guiTimer.timeout.connect(self.guiUpdate)

		# ShortCut
		self.ui.actionRecord_Data.setShortcut("Ctrl+D")

		# Check is there are the data valid or not
		self.judgeStatusCheck()

		# Show the main window
		self.show()

	def voltageUpdate(self):
		# skip the first update to making sure we get the whole string
		if not self.init:
			self.init = True
			return

		data = self.arduino.readline().decode('utf-8')
		if data:
			self.time = str(datetime.datetime.now())
			self.measure = data
			self.updatePosture()

			# record the data is data recorder is open
			if self.recorder is not None and self.recorder.recording:
				posture_id = self.recorder.ui.ComboClass.currentIndex()
				self.recorder.measure[posture_id].append('\t'.join((self.time, self.measure)))


			# send the message as raw binary
			# self.arduino.write(struct.pack('>B',led_out))

	def updatePosture(self):
		curr_predict = self.judge.predict(self.measure)
		if curr_predict == self.predict['curr_predict']:
			self.predict['cnt'] += 1
		else:
			self.predict['curr_predict'] = curr_predict
			self.predict['cnt'] = 1

		if self.predict['cnt'] >= Constants.consecutiveFactor:
			self.predict['predict'] = self.predict['curr_predict']

	def recordData(self):
		self.recorder = DataRecorder(self)
		self.recorder.finished.connect(self.recordDataClose)

	def judgeStatusCheck(self):
		# Show the data recorder window if there are no data
		if self.judge.clf is None:
			QMessageBox.warning(self, 'warning', 'Please record some data to initialize the service')
			self.recordData()

	def recordDataClose(self, val):
		if val == 1:
			self.dumpStoringData()
		self.recorder = None
		self.judge.initialize()
		self.judgeStatusCheck()

	def dumpStoringData(self):
		# dump the recording data when data recorder is done. (press ok)
		for class_id, data in self.recorder.measure.items():
			filename = join(Constants.DATA_DIR, 'class' + str(class_id - 1) + '.txt')
			with open(filename, 'w+') as file:
				for row in data:
					file.write(row)

	def guiUpdate(self):
		# convert a list of float to 0 ~ 255 in stylesheet format
		def getFormatColor(raw_color):
			res = 'rgb('
			res += ', '.join([str(int(i * 255)) for i in raw_color])
			res += ')'
			return res
		
		# convert volt into color
		def getColorMap(volts, cm):
			res = []
			for v in volts.split('\t'):
				color = cm(int(float(v) / 5.01 * 255))
				res.append(getFormatColor(color))

			return res



		# update the pressure heatmap
		if self.measure is not None:
			colors = getColorMap(self.measure, self.cm)
			self.ui.bottomBack.setStyleSheet('QWidget { background: %s }' % colors[0])
			self.ui.bottomLeft.setStyleSheet('QWidget { background: %s }' % colors[1])
			self.ui.bottomRight.setStyleSheet('QWidget { background: %s }' % colors[2])
			self.ui.backLeft.setStyleSheet('QWidget { background: %s }' % colors[3])
			self.ui.backRight.setStyleSheet('QWidget { background: %s }' % colors[4])
			self.ui.backDown.setStyleSheet('QWidget { background: %s }' % colors[5])

		# update the posture image
		filename = str(Posture(self.predict['predict'])) + '.png'
		self.ui.imageHolder.setPixmap(QPixmap(join(Constants.IMG_DIR, filename)))
		self.ui.imageHolder.show()



class DataRecorder(QDialog):
	def __init__(self, parent=None):
		# UI init
		super(QDialog, self).__init__(parent)
		self.ui = Ui_DataRecorder()
		self.ui.setupUi(self)
		self.updateComboBox()
		self.setPosturePicture(0)
		self.parent = parent
		self.recording = False
		self.measure = defaultdict(list)
		self.guiTimer = QTimer()
		self.guiTimer.start(0)

		# Connection
		self.ui.ComboClass.currentIndexChanged.connect(self.setPosturePicture)
		self.ui.RecordingButton.clicked.connect(self.recordingClicked)
		self.guiTimer.timeout.connect(self.guiUpdate)
		# show the window
		self.show()

	def updateComboBox(self):
		for i in range(1, len(Posture)):
			self.ui.ComboClass.addItem(str(Posture(i)))

	def setPosturePicture(self, value):
		filename = str(Posture(value)) + '.png'
		self.ui.imageHolder.setPixmap(QPixmap(join(Constants.IMG_DIR, filename)))
		self.ui.imageHolder.show()

	def recordingClicked(self):
		# pop out a warning window if posture id is selected
		if self.ui.ComboClass.currentIndex() == 0:
			QMessageBox.warning(self, 'warning', 'You need to select a posture to record the data')
			return

		self.recording = not self.recording
		# using guiUpdate to update the gui
		
	def guiUpdate(self):
		buttonMsg = 'Stop Recording' if self.recording else 'Start Recording'
		self.ui.ComboClass.setEnabled(not self.recording)
		self.ui.RecordingButton.setText(buttonMsg)
