# ui generated by pyuic5 MainWindow.ui -o ui_MainWindow.py

from PyQt5.QtWidgets import QMainWindow, QDialog, QShortcut, QMessageBox

from UIs.ui_MainWindow import Ui_MainWindow
from UIs.ui_RecordData import Ui_DataRecorder
from PyQt5.QtCore import QTimer
from PyQt5.QtGui import QPixmap, QKeySequence, QGuiApplication

from ArduinoTest import ArduinoTest
import Constants

import serial
import struct
import datetime
from collections import defaultdict
from os.path import join
import os


class MainWindow(QMainWindow):
	def __init__(self, test=False, port=None, parent=None):
		# UI init
		super(MainWindow, self).__init__(parent)
		self.ui = Ui_MainWindow()
		self.ui.setupUi(self)

		self.ledOn = False
		self.voltageTimer = QTimer()
		self.voltageTimer.start(100)		# update every 0.1 second
		self.init = False					# will be removed when hand-shake is added
		self.recorder = None
		self.time = None
		self.measure = None


		# check it is test mode or not (arduino don't need to connect)
		if test:
			self.arduino = ArduinoTest()
		else:
			self.arduino = serial.Serial(port, 9600, timeout=.1)

		# Connection
		self.ui.ledButton.clicked.connect(self.ledButtonClicked)
		self.voltageTimer.timeout.connect(self.voltageUpdate)
		self.ui.actionRecord_Data.triggered.connect(self.recordData)

		# ShortCut
		self.ui.actionRecord_Data.setShortcut("Ctrl+D")

		# Show the main window
		self.show()

	def ledButtonClicked(self):
		value = b'0' if self.ledOn else b'1'
		msg = 'Off' if self.ledOn else 'On'
		self.arduino.write(value)
		self.ledOn = not self.ledOn
		self.ui.ledButton.setText(msg)

	def voltageUpdate(self):
		# skip the first update to making sure we get the whole string
		if not self.init:
			self.init = True
			return

		data = self.arduino.readline().decode('utf-8')
		if data:
			self.ui.voltage.setText(data)
			self.time = str(datetime.datetime.now())
			self.measure = data
			
			# record the data is data recorder is open
			if self.recorder is not None and self.recorder.recording:
				posture_id = self.recorder.ui.ComboClass.currentIndex()
				self.recorder.measure[posture_id].append(' '.join((self.time, self.measure)))


			
			# send the message as raw binary
			# self.arduino.write(struct.pack('>B',led_out))

	def recordData(self):
		self.recorder = DataRecorder(self)
		self.recorder.finished.connect(self.recordDataClose)

	def recordDataClose(self, val):
		if val == 1:
			self.dumpStoringData()
		self.recorder = None

	def dumpStoringData(self):
		# dump the recording data when data recorder is done. (press ok)
		for class_id, data in self.recorder.measure.items():
			filename = join(Constants.DATA_DIR, 'class' + str(class_id - 1) + '.txt')
			with open(filename, 'w+') as file:
				for row in data:
					file.write(row + '\n')


class DataRecorder(QDialog):
	def __init__(self, parent=None):
		# UI init
		super(QDialog, self).__init__(parent)
		self.ui = Ui_DataRecorder()
		self.ui.setupUi(self)
		self.parent = parent
		self.ui.imageHolder.setPixmap(QPixmap(join(Constants.IMG_DIR, '0.png')))
		self.recording = False
		self.measure = defaultdict(list)

		# Connection
		self.ui.ComboClass.currentIndexChanged.connect(self.setPosturePicture)
		self.ui.RecordingButton.clicked.connect(self.recordingClicked)

		# show the window
		self.show()

	def setPosturePicture(self, value):
		filename = str(value) + '.png'
		self.ui.imageHolder.setPixmap(QPixmap(join(Constants.IMG_DIR, filename)))
		self.ui.imageHolder.show()

	def recordingClicked(self):
		# pop out a warning window if posture id is selected
		if self.ui.ComboClass.currentIndex() == 0:
			QMessageBox.warning(self, 'warning', 'You need to select a posture to record the data')
			return

		self.recording = not self.recording
		buttonMsg = 'Stop Recording' if self.recording else 'Start Recording'
		self.ui.ComboClass.setEnabled(not self.recording)
		self.ui.RecordingButton.setText(buttonMsg)
		print('recording:', self.recording)
